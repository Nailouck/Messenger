# Messenger
Это БДЗ №1.
Задача состоит в создании примитивного чата на двух пользователей с сервером на сокетах.

## server.c
Этот исходник создаёт сервер для последующего обмена сообщениями с клиентом.

### Подключаемые библиотеки и заголовочные файлы:
<stdlib.h> для подключения функции atoi, которая конвертирует строку в число.
<stdio.h> для подключения функции puts, которая выводит данные в консоль.
<string.h> для подключения функции strcmp, которая сравнивает две строки.
<sys/socket.h> - это основополагающая библиотека для данного проекта. Она используется для создания и использования сокетов на Linux.
<arpa/inet.h> для подключения функции htons, которая преобразует число с фиксированной запятой в IP адрес. Кроме того, в этой библиотеке определена INADDR_ANY, которая позволяет подключиться к любому свободному адресу связывания, а также структура sockaddr_in, которая хранит Адрес для подключения сокета.
"err_proc.h" для обработки ошибок.
"message.h" для чтения и передачи сообщений.

### Код:
```
extern const int BUFF_SIZE;
```
Дикларируем константу BUFF_SIZE, которая инициализирована в messange.c и означает размер буфера.

```
if (argc < 2) {
    puts("Not enough program arguments! Example: ./server.o <port>\n");
    return -1;
}
```
Проверяем, ввёл ли пользователь порт для подключения, если нет, завершаем программу с кодом -1 - недостаточное количество входных данных.

```
int server_socket = Socket(AF_INET, SOCK_STREAM, 0);
```
Создаём сокет, используя обёрточную функцию из файла err_proc.h, передаём на вход AF_INET - семейство протоколов, SOCK_STREAM - тип сокета (в нашем случае потоковый) и протокол (при передаче нуля, используется значение по умолчанию)

```
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(atoi(argv[1]));
addr.sin_addr.s_addr = INADDR_ANY;
```
Инициализируем структуру addr, которая хранит sin_family = AF_INET - семейство протоколов, sin_port - порт для подключения, который вводится пользователем при запуске программы и конвертируется сначала в число с помощью функции atoi, потом - в IP адрес с помощью функции htons. В addr.sin_addr.s_addr хранится адрес связывания (в нашем случае это INADDR_ANY, что означает, что нам подойдёт любой свободный адрес)

```
Bind(server_socket, (struct sockaddr*) &addr, sizeof(addr));
Listen(server_socket, 1);
```
Связываем сокет с конкретным адресом, т. е. с нашей структурой sockaddr_in addr, после чего ставим его "в режим прослушивания" в ожидании одного подключения.

```
socklen_t adrlen = sizeof addr;
int client_socket = Accept(server_socket, (struct sockaddr*) &addr, &adrlen);
```
Принимаем и инициализируем клиентский сокет.

```
char buff[BUFF_SIZE];
struct message msg;
msg.buff = buff;
msg.socket = client_socket;
```
Инициализируем структуру message msg которая хранит buff - буфер для передачи сообщений, сокет, с которым будет проводиться передачасообщений и ssize_t nread - количество считанных байтов.

```
do {
    read_msg(msg);
    write_msg(msg);
} while (strcmp(msg.buff, "E\n\0") != 0);
```
Запускаем цикл передачи сообщений в порядки очереди, т. е. сначала сервер принимает сообщение, потом отправляет, затем снова принимает и т. д. Цикл закончится, если сервер введёт "E" или если клиент отключится (через пару проходов цикла он закончится). Функции read_msg и write_msg описаны в message.c.

```
sleep(1);
close(client_socket);
close(server_socket);
return 0;
```
Ждём 1 секунду, после чего последовательно закрываем сокет клиента и сокет сервера. Завершаем программу с кдом 0 - программа завершилась успешно.

## client.c
Этот исходник создаёт соект клиента, который подключается к серверу для последующего обмена сообщениями.

### Подключаемые библиотеки и заголовочные файлы:
<stdlib.h> для подключения функции atoi, которая конвертирует строку в число.
<stdio.h> для подключения функции puts, которая выводит данные в консоль.
<string.h> для подключения функции strcmp, которая сравнивает две строки.
<sys/socket.h> - это основополагающая библиотека для данного проекта. Она используется для создания и использования сокетов на Linux.
<arpa/inet.h> для подключения функции htons, которая преобразует число с фиксированной запятой в IP адрес. Кроме того, в этой библиотеке определена INADDR_ANY, которая позволяет подключиться к любому свободному адресу связывания, а также структура sockaddr_in, которая хранит Адрес для подключения сокета.
"err_proc.h" для обработки ошибок.
"message.h" для чтения и передачи сообщений.

### Код:
```
extern const int BUFF_SIZE;
```
Дикларируем константу BUFF_SIZE, которая инициализирована в messange.c и означает размер буфера.

```
if (argc < 2) {
    puts("Not enough program arguments! Example: ./server.o <port>\n");
    return -1;
}
```
Проверяем, ввёл ли пользователь порт для подключения, если нет, завершаем программу с кодом -1 - недостаточное количество входных данных.

```
int client_socket = Socket(AF_INET, SOCK_STREAM, 0);
```
Создаём сокет, используя обёрточную функцию из файла err_proc.h, передаём на вход AF_INET - семейство протоколов, SOCK_STREAM - тип сокета (в нашем случае потоковый) и протокол (при передаче нуля, используется значение по умолчанию)

```
struct sockaddr_in addr;
addr.sin_family = AF_INET;
addr.sin_port = htons(atoi(argv[1]));
addr.sin_addr.s_addr = INADDR_ANY;
```
Инициализируем структуру addr, которая хранит sin_family = AF_INET - семейство протоколов, sin_port - порт для подключения, который вводится пользователем при запуске программы и конвертируется сначала в число с помощью функции atoi, потом - в IP адрес с помощью функции htons. В addr.sin_addr.s_addr хранится адрес связывания (в нашем случае это INADDR_ANY, что означает, что нам подойдёт любой свободный адрес)

```
Connect(client_socket, (struct sockaddr*)&addr, sizeof(addr));
```
Посылаем запрос на присоединение к серверу.

```
char buff[BUFF_SIZE];
struct message msg;
msg.buff = buff;
msg.socket = client_socket;
```
Инициализируем структуру message msg которая хранит buff - буфер для передачи сообщений, сокет, с которым будет проводиться передачасообщений и ssize_t nread - количество считанных байтов.

```
do {
	write_msg(msg);
	if (strcmp(msg.buff, "E\n\0") == 0) { break; }
	read_msg(msg);
}
while (1);
```
Запускаем цикл передачи сообщений в порядки очереди, т. е. сначала клиент отправляет сообщение, потом принимает, затем снова отправляет и т. д. Цикл закончится, если клиент введёт "E" или если сервер отключится (через пару проходов цикла он закончится). Функции read_msg и write_msg описаны в message.c.

```
close(client_socket);
return 0;
```
Закрываем сокет клиента и завершаем программу с кодом 0 - программа завершилась успешно.
